package org.lubbenb.raytracer;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.GraphicsEnvironment;
import java.awt.Transparency;
import java.awt.image.BufferedImage;
import java.awt.image.ColorModel;
import java.awt.image.WritableRaster;
import java.util.List;

import org.lubbenb.math.KDTree;
import org.lubbenb.math.Point3D;
import org.lubbenb.math.Vector3D;
import org.lubbenb.raytracer.lights.Light;
import org.lubbenb.raytracer.objects.Camera;
import org.lubbenb.raytracer.objects.Object;
import org.lubbenb.raytracer.scene.Scene;
import org.lubbenb.raytracer.shaders.Shader;


public abstract class RayTracer {
	protected static final long serialVersionUID = 1L;

	protected static final double epsilon = .00001;

	// List of objects in the scene
	protected List<Object> c;
	
	protected ObjectContainer oc;

	// List of lights in the scene
	protected List<Light> l;
	
	protected List<Shader> shaders;

	// Background color
	protected Color background;

	// Max depth of reflections
	protected int max_depth = 10;
	
	protected boolean skipKD = false;
	
	protected boolean depthRender = false;
	
	protected double nativeRefractionIndex = 1.0;

	// The location of the image generated by renderScene
	protected BufferedImage renderedImage;

	// Camera in the scene
	protected Camera camera;
	
	protected Dimension size;
	
	protected KDTree tree;
	
	protected int stat;
	protected int n;

	/*
	 * This function renders the scene and returns it as a buffered image
	 */
	public BufferedImage renderScene(Scene s) throws InterruptedException {
		loadScene(s);
		ColorModel model = GraphicsEnvironment.getLocalGraphicsEnvironment()
				.getDefaultScreenDevice().getDefaultConfiguration()
				.getColorModel(Transparency.OPAQUE);
		WritableRaster wr = model.createCompatibleWritableRaster(500, 500);
		renderedImage = new BufferedImage(model, wr, model
				.isAlphaPremultiplied(), null);

		Graphics g = renderedImage.getGraphics();
		render(g);
		return renderedImage;
	}

	/*
	 * This renders the scene to the graphics object
	 */
	public void renderNOW(Graphics g, Scene s) throws InterruptedException {
		loadScene(s);
		render(g);
	}

	/*
	 * Main constructor
	 */
	public RayTracer(Dimension d) {
		size = d;
	}

	/*
	 * Loads the scene
	 */
	public void loadScene(Scene s) {
		shaders = s.getShaders();
		c = s.getObjects();
		for(int i=0; i<c.size(); i++)
			c.get(i).setID(i);
		
		oc = new KDTree(c);
		long lt = System.currentTimeMillis();
		oc.build();
		System.out.println("tree build: "+(System.currentTimeMillis()-lt)/1000.0+" seconds");
		l = s.getLights();
		camera = s.getCamera();
		background = s.getBackground();
	}

	
	/*
	 * Calculates the lighting data as a double[]
	 */
	public double[] calculateLighting(Ray r, Intersection intersection) {
		// Lighting data for shader use
		double[] intensity = null;

		// ID of the nearest object that the light ray intersects
		int nearestObject = intersection.getObjectID();

		// The shader of the nearest object
		Shader shader = shaders.get(nearestObject);

		// Go through all the lights to calculate the lighting information
		for (Light light : l) {
			// Nearest object of the light ray
			Intersection no = null;
			double lightIntensity = 0;
			double[] sampleIntensity = null;
			double[] sampleAverage = null;

			for (int a = 0; a < light.getNumberOfSamples(); a++) {
				Point3D sample = light.getSample();

				// System.out.println(sampleLoc[0]+","+sampleLoc[1]+","+sampleLoc[2]);

				// Start a new ray from the intersection point
				//lightRay.setOrigen(sampleLoc[0], sampleLoc[1], sampleLoc[2]);
				Ray lightRay = new Ray(intersection.getIntersection().getVector(), sample.subtract(intersection.getIntersection()).getVector());
				Ray lightRay2 = new Ray(sample.getVector(), lightRay.getDirection().negate());

				lightIntensity = light.getIntensity(lightRay);
				no = oc.getNearestObject(lightRay2);
				
				boolean closeEnough = false;
				if (Math.abs(no.getX() - intersection.getX()) < epsilon
						&& Math.abs(no.getY() - intersection.getY()) < epsilon
						&& Math.abs(no.getZ() - intersection.getZ()) < epsilon) {
					closeEnough = true;
				}

				//if (no.getObjectID() == nearestObject || closeEnough) {
				if (no.getObjectID() == nearestObject&&closeEnough) {
					sampleIntensity = shader.calculateIntensity(lightRay,
							lightIntensity, c.get(nearestObject)
									.getNormal(intersection.getX(),
											intersection.getY(), intersection
													.getZ()), r);

					sampleAverage = shader.addIntensity(sampleAverage,
							sampleIntensity);
				}
			}

			if (light.getNumberOfSamples() == 0) {
				intensity = shader.addIntensity(shader.calculateIntensity(
						null, lightIntensity, c
								.get(nearestObject).getNormal(intersection
								.getX(), intersection.getY(), intersection
								.getZ()), r), intensity);
			} else {
				intensity = shader.addIntensity(shader.averageIntensity(
						sampleAverage, light.getNumberOfSamples()), intensity);
			}

		}

		return intensity;
	}

	public Color calculateReflectionColor(Ray r, Intersection intersection,
			int count) {
		int nearestObject = intersection.getObjectID();

		Ray normal = (c.get(nearestObject)).getNormal(intersection
				.getX(), intersection.getY(), intersection.getZ());

		double angle = 2 * (-r.getDirectionX() * normal.getDirectionX() + -r.getDirectionY()
				* normal.getDirectionY() + -r.getDirectionZ() * normal.getDirectionZ());

		Vector3D reflect = normal.getDirection().scalarMultiply(angle).add(new Vector3D(epsilon, epsilon, epsilon));

		return rayTrace(new Ray(normal.getOrigin(), reflect), count);
	}
	
	public Color calculateRefractionColor(Ray r, Intersection intersection,
			int count) {

		int nearestObject = intersection.getObjectID();
		// Calculate reflection
		Vector3D normal = (c.get(nearestObject)).getNormal(intersection
				.getX(), intersection.getY(), intersection.getZ()).getDirection().normalize();
		Vector3D incident = r.getDirection().normalize();

		// Calculate refraction
		double refractionIndex = (c.get(nearestObject)).getMaterial().getRefractionIndex();
		
		double n = nativeRefractionIndex/refractionIndex;
		double cosI = normal.dotProduct(incident);
		double sinT2 = n * n * (1.0 - cosI * cosI);
		if (sinT2 > 1.0)
		{
			return Color.BLACK;
		}

		Vector3D direction = incident.scalarMultiply(n).subtract(normal.scalarMultiply(n + Math.sqrt(1.0 - sinT2)));
		
		return rayTrace(new Ray(intersection.getIntersection().getVector(), direction), count);
	}

	public Color rayTrace(Ray r, int count) {
		count++;
		if (count < max_depth) {
			Intersection intersection;
			intersection = oc.getNearestObject(r);

			int nearestObject = intersection.getObjectID();

			if (nearestObject != -1) {
				if(!depthRender){
					double lighting[] = calculateLighting(r, intersection);
	
					double ri = c.get(nearestObject).getMaterial()
							.getReflections();
					double t = c.get(nearestObject).getMaterial()
					.getTransparency();
					
					Color tc = null;
					Color rc = null;
					if (ri > 0)
						rc = calculateReflectionColor(r, intersection, count);
					
					if(t > 0)
						tc = calculateRefractionColor(r, intersection, count);
	
					Shader s = shaders.get(nearestObject);

					return s.shade(c.get(nearestObject), intersection, lighting, rc, tc);
				} else {
					double distance = intersection.getIntersect();
					double color = (distance-5)/20*255;
					
					if(color>255)
						color = 255;
					if(color<1)
						color=1;
					Color c = new Color(0, 0, (int)(color));
					System.out.println(color);
					return c;
				}
			} else {
				return background;
			}
		} else {
			return null;
		}
	}

	abstract public void render(final Graphics g);

	public void paint(Graphics g) throws InterruptedException {
		render(g);
	}
}
